import os
import oct2py
import numpy as np
import matplotlib.pyplot as plt
from scipy.constants import speed_of_light
from scipy.signal import windows, correlate
from scipy.io import savemat
from joblib import Parallel, delayed
from scipy.signal import firwin, lfilter


#generated by Gemini
def plot_windowed_fft(signal, sampling_rate, window_length, hop_length, title="Windowed FFT"):
    """
    Computes and plots the windowed Short-Time Fourier Transform (STFT) of a real-valued signal,
    showing the evolution of the peak frequency over time.

    Args:
        signal (numpy.ndarray): The input real-valued signal.
        sampling_rate (float): The sampling rate of the signal in Hz.
        window_length (int): The length of the analysis window in samples.
        hop_length (int): The hop length (stride) between consecutive windows in samples.
        title (str, optional): Title of the plot. Defaults to "Windowed FFT".
    """
    # Ensure the input signal is a NumPy array
    if not isinstance(signal, np.ndarray):
        try:
            signal = np.array(signal)
        except:
            raise ValueError("Input signal must be convertible to a NumPy array.")
    if signal.ndim != 1:
        raise ValueError("Input signal must be a one-dimensional array.")
    if not np.isrealobj(signal):
        raise ValueError("Input signal must be real-valued.")
    n = len(signal)
    n_fft = window_length #often the same, but can be different
    n_windows = int(np.floor((n - window_length) / hop_length) + 1)
    frequencies = np.fft.fftfreq(n_fft, 1/sampling_rate)
    positive_frequencies = frequencies[:n_fft//2] #keep only positive freqs
    peak_frequencies = np.zeros(n_windows)
    window_times = np.zeros(n_windows)
    windowed_fft_values = [] # List to store the full FFT data for each window
    window = windows.hann(window_length)
    for i in range(n_windows):
        start = i * hop_length
        end = start + window_length
        signal_window = signal[start:end]
        windowed_signal = signal_window * window
        fft_result = np.fft.fft(windowed_signal, n_fft) #compute fft
        fft_magnitude = np.abs(fft_result[:n_fft//2]) #get magnitude
        windowed_fft_values.append(fft_magnitude) #store fft data
        peak_index = np.argmax(fft_magnitude[1:]) + 1  # +1 to exclude DC (index 0)
        peak_frequencies[i] = positive_frequencies[peak_index] #get freq
        if fft_magnitude[peak_index] < 1:
            peak_frequencies[i] = 0
        window_times[i] = start / sampling_rate + window_length / (2 * sampling_rate)

    plt.figure(figsize=(5, 3))
    plt.plot(window_times, peak_frequencies)
    plt.title(title)
    plt.xlabel("Time (s)")
    plt.ylabel("Peak Frequency (Hz)")
    plt.grid(True)
    plt.tight_layout()
    plt.show()

    return window_times, peak_frequencies, positive_frequencies, windowed_fft_values #return additional data


# requires data_cube to be (P pulses, N samples)
def doppler_process(data_cube, prf, center_frequency, filter=False):
    if data_cube.ndim != 2:
        raise ValueError("Input data_cube must be a 2D array (P_pulses, N_samples).")

    P_pulses, N_samples = data_cube.shape

    doppler_data = np.fft.fftshift(np.fft.fft(data_cube, axis=0), axes=0)
    Q = doppler_data.shape[0]

    # # sketchy [-1, 2, -1] sharpening filter to clean up some of the the FFT spread
    # if filter:
    #     doppler_filter = np.zeros((Q, Q), dtype=np.complex128)
    #     for i in range(Q):
    #         doppler_filter[i, i] = 2
    #         if i > 0:
    #             doppler_filter[i, i-1] = -1
    #         if i < (Q-1):
    #             doppler_filter[i, i+1] = -1
        
    #     doppler_data = doppler_filter @ doppler_data

    if filter:
        doppler_data[13:20] = 0j

    doppler_axis = np.fft.fftshift(np.fft.fftfreq(doppler_data.shape[0], d=1/prf))
    velocity_axis = -1 * doppler_axis * speed_of_light / center_frequency
    return doppler_data, velocity_axis


# requires doppler_data to be (Q doppler bins, N samples)
# the threshold is only necessary if not adding noise, since a completely clean signal flummoxes the detector
def pulse_compress(doppler_data, tx_pulse, sampling_rate, taper=False, threshold=False, threshold_val=5, simulated_data=False):

    if doppler_data.ndim != 2:
        raise ValueError("Input doppler_data must be a 2D array (Q_doppler_bins, N_samples).")

    Q_doppler_bins, N_samples = doppler_data.shape
    pulse = tx_pulse

    if taper:
        window = windows.taylor(len(pulse), nbar=4, sll=40)
        pulse = pulse * window

    # TODO: fix range axis discrepancy
    if simulated_data:
        replica_fft = np.fft.fft(pulse, n=N_samples)
        replica_fft_conj = np.conj(replica_fft)

        pulse_compressed_data = np.zeros_like(doppler_data, dtype=complex)

        # Correlate the TX signal with each pulse
        for q in range(Q_doppler_bins):
            range_profile = doppler_data[q, :]
            range_profile_fft = np.fft.fft(range_profile)
            compressed_fft = range_profile_fft * replica_fft_conj
            pulse_compressed_data[q, :] = np.fft.ifft(compressed_fft)

        if threshold:
            abs_pc = np.abs(pulse_compressed_data)
            pulse_compressed_data[abs_pc < threshold_val] = 0

        N_range_bins = pulse_compressed_data.shape[1]
        total_time = N_range_bins / sampling_rate
        total_range = total_time * speed_of_light
        range_axis = np.linspace(0, total_range, N_range_bins)
        return pulse_compressed_data, range_axis

    else:
        corr_length = pulse.shape[0] + N_samples - 1
        # print("Correlation length: ", corr_length)

        # pulse_zp = np.zeros(corr_length, dtype=np.complex128)
        # pulse_zp[0:pulse.shape[0]] = pulse

        # # replica_fft = np.fft.fft(pulse, n=N_samples)
        # replica_fft = np.fft.fft(pulse_zp)
        # replica_fft_conj = np.conj(replica_fft)

        # pulse_compressed_data = np.zeros_like(doppler_data, dtype=complex)
        pulse_compressed_data = np.zeros((Q_doppler_bins, corr_length - 2 * pulse.shape[0]), dtype=np.complex128)
        pulse_compressed_data = np.zeros((Q_doppler_bins, corr_length), dtype=np.complex128)
        
        # print("PC data shape: ", pulse_compressed_data.shape)
        # Correlate the TX signal with each pulse
        for q in range(Q_doppler_bins):
            # range_profile = doppler_data[q, :]
            # range_profile_zp = np.zeros(corr_length, dtype=np.complex128)
            # range_profile_zp[0:N_samples] = range_profile
            # range_profile_fft = np.fft.fft(range_profile_zp)
            # compressed_fft = range_profile_fft * replica_fft_conj
            # pulse_compressed_data[q, :] = np.fft.ifft(compressed_fft)[pulse.shape[0]:-pulse.shape[0]]
            out = np.convolve(doppler_data[q], pulse, mode="same")
            pulse_compressed_data[q, 0:out.shape[0]] = out

        if threshold:
            abs_pc = np.abs(pulse_compressed_data)
            pulse_compressed_data[abs_pc < threshold_val] = 0

        N_range_bins = pulse_compressed_data.shape[1]
        total_time = N_range_bins / sampling_rate
        # print("Total time: ", total_time)
        total_range = total_time * speed_of_light
        range_axis = np.linspace(0, total_range, N_range_bins) - (30 + 5000/sampling_rate * speed_of_light)
        return pulse_compressed_data, range_axis


def generate_LFM_pulse(sampling_rate, pulse_duration, bandwidth, time_flip=False):
    t = np.linspace(0, pulse_duration, int(sampling_rate * pulse_duration))

    if time_flip:
        return np.exp(-2j * np.pi * t * (-bandwidth/2 + ((bandwidth * t)/(2 * pulse_duration))))
    else:
        return np.exp(2j * np.pi * t * (-bandwidth/2 + ((bandwidth * t)/(2 * pulse_duration))))


# Doppler effect included
def generate_PRI_samples(sampling_rate, pulse_duration, pri_duration, pulses_per_cpi, bandwidth, center_frequency, target_distance, target_radial_velocity):
    pulse_length = int(pulse_duration * sampling_rate)
    pri_length = int(pri_duration * sampling_rate)
    cpi_length = pri_length * pulses_per_cpi
    cpi = np.zeros((pulses_per_cpi, pri_length), dtype=np.complex128)

    wavelength = speed_of_light / center_frequency

    propagation_delay = target_distance / speed_of_light
    propagation_samples = int(propagation_delay * sampling_rate)

    doppler_shift = -target_radial_velocity / wavelength

    t = np.arange(cpi_length) / sampling_rate
    doppler_waveform = np.exp(2j * np.pi * doppler_shift * t)
    pulse = generate_LFM_pulse(sampling_rate=sampling_rate, pulse_duration=pulse_duration, bandwidth=bandwidth)
    for i in range(pulses_per_cpi):
        offset = i*pri_length + propagation_samples
        cpi[i, propagation_samples:propagation_samples+pulse_length] = pulse * doppler_waveform[offset:offset+pulse_length]

    return cpi, pulse


def flatten_cpi(cpi, sampling_rate, pri_duration, pulses_per_cpi):
    pri_length = int(pri_duration * sampling_rate)
    cpi_whole = np.zeros(pulses_per_cpi * pri_length, dtype=np.complex128)
    
    for i in range(pulses_per_cpi):
        cpi_whole[i*pri_length:(i+1)*pri_length] = cpi[i]
    
    return cpi_whole


def make_cpi(cpi_whole, sampling_rate, pri_duration, pulses_per_cpi):
    pri_length = int(pri_duration * sampling_rate)
    cpi = np.zeros((pulses_per_cpi, pri_length), dtype=np.complex128)

    for i in range(pulses_per_cpi):
        cpi[i] = cpi_whole[i*pri_length:(i+1)*pri_length]
    
    return cpi


# wideband timeshift that shifts every frequency by the same shift (in seconds)
def timeshift(signal, sampling_rate, center_frequency, shift, already_fft=False):
    N = len(signal)
    
    if already_fft:
        signal_freq = signal # no need to recompute FFT
    else:
        signal_freq = np.fft.fft(signal)
        
    freqs = np.fft.fftfreq(N, d=1/sampling_rate) + center_frequency
    shift_ramp = np.exp(-2j * np.pi * freqs * shift)
    signal_freq_shifted = signal_freq * shift_ramp
    return np.fft.ifft(signal_freq_shifted)


# unit vectors in SOAP coordinate system
def create_ned_unit_vector(az, el):
    az = -az
    return np.asarray([
        np.cos(el) * np.cos(az), 
        np.cos(el) * np.sin(az), 
        np.sin(el)
    ])

def create_shifted_positions(positions_file):
    raw_pos = np.load(positions_file)
    num_ele_east = 32       # number of elements along east direction
    num_ele_down = 4     # number of elements along down direction
    east_offset = 0 #(num_ele_east/2 - 0.5) * 3/90
    down_offset = 0 #(num_ele_down/2 - 0.5) * 3/90
    shifted_pos = raw_pos + np.asarray([0, east_offset, down_offset])
    shifted_pos_T = np.permute_dims(shifted_pos, axes=(1, 0, 2)).reshape(128, 3)
    # print(raw_pos.shape)
    # print("Shifted pos T shape:", shifted_pos_T.shape)
    return shifted_pos_T


def create_steering_vector_radar_coords(azimuth, elevation, positions, frequency, center_frequency=4e9):
    uv = create_ned_unit_vector(azimuth, elevation)
    delays = np.dot(positions, uv)
    sv_2D = np.exp(-2j * np.pi * (center_frequency+frequency) * delays / speed_of_light)

    return sv_2D

# # delay-sum beamformer where signals are (NumElements, NumSamples)
# # positions are read from the .json directly and it uses actual light travel time
def beamform_timeshift_2D(signals, positions, azimuth, elevation, sampling_rate, center_frequency):
    uv = create_ned_unit_vector(azimuth, elevation)
    
    def run_beamform_timeshift(pos, uv, signal, sampling_rate, center_frequency):
        light_delay = np.dot(pos, uv) / speed_of_light
        shift = -light_delay
        return timeshift(signal, sampling_rate=sampling_rate, center_frequency=center_frequency, shift=shift)
    
    res = Parallel(n_jobs=-1)(delayed(run_beamform_timeshift)(positions[i], uv, signals[i], sampling_rate, center_frequency) for i in range(positions.shape[0]))
    res_arr = np.asarray(res)
    print("Beamform Res shape: ", res_arr.shape)
    return np.sum(res_arr, axis=0)

# create radar signals
def response_timeshift_2D(signal, positions, azimuth, elevation, sampling_rate, center_frequency):
    uv = create_ned_unit_vector(azimuth, elevation)
    resp_out = np.zeros((positions.shape[0], signal.shape[0]), dtype=np.complex128)
    signal_freq = np.fft.fft(signal)
    
    def run_response_timeshift(pos, uv, signal_freq, sampling_rate, center_frequency):
        light_delay = np.dot(pos, uv) / speed_of_light
        shift = light_delay
        return timeshift(signal_freq, sampling_rate=sampling_rate, center_frequency=center_frequency, shift=shift, already_fft=True)
    
    resp_out = Parallel(n_jobs=-1)(delayed(run_response_timeshift)(positions[i], uv, signal_freq, sampling_rate, center_frequency) for i in range(positions.shape[0]))
    return np.asarray(resp_out)



# runs detection pipeline using octave
# data_cube is (P pulses, N SamplesPerPulse)
# code_path is dir where reference detection code is stored
def run_detection_pipeline_single(data_cube, pulse_replica, code_path, sampling_rate, pri_duration, center_frequency, radial_vel=None, doppler_filter=False, pc_taper=True, simulated_data=False, matfile_name="test.mat", viz=False, vmax=1000, target_idx=0):
    oc = oct2py.Oct2Py()
    oc.addpath(code_path)

    data_cube_dp, velocity_axis = doppler_process(data_cube, prf=1/pri_duration, center_frequency=center_frequency, filter=doppler_filter)
    # find the closes vel

    if radial_vel != None:
        velocity_bin = np.argmin(np.abs(velocity_axis - radial_vel))
        for i in range(32):
            if i != velocity_bin:
                data_cube_dp[i] = 0

    data_cube_pc, range_axis = pulse_compress(data_cube_dp, pulse_replica, sampling_rate, taper=pc_taper, threshold=False, threshold_val = 0.00000001, simulated_data=simulated_data)
    data_cube_viz = np.abs(data_cube_pc)

    # print(range_axis[1] - range_axis[0])

    mat = {
        "num_Doppler_bins": 32,
        "range_cell_width": range_axis[1] - range_axis[0],
        "range_bins": range_axis,
        "Doppler_bins": velocity_axis,
        "data_cube": data_cube_pc.T
    }

    if os.path.exists(matfile_name):
        if os.path.isfile(matfile_name):
            os.remove(matfile_name)

    savemat(matfile_name, mat)
    # print("matfile saved...running octave...")

    things = oc.run_detection(matfile_name, nout=4)

    if viz:
        plt.figure(figsize=(15, 15))
        max_value = np.max(data_cube_viz)
        min_value = np.min(data_cube_viz)
        print(max_value, min_value)
        num_ticks = 10
        N = len(range_axis)
        x_tick_locations_float = np.linspace(0, N - 1, num_ticks)
        x_tick_indices = np.round(x_tick_locations_float).astype(int)
        x_tick_indices = np.clip(x_tick_indices, 0, N - 1)
        x_tick_labels = [f'{int(range_axis[int(idx)])}' for idx in x_tick_indices]
        plt.xticks(x_tick_locations_float, x_tick_labels)
        plt.yticks(np.arange(len(velocity_axis)), velocity_axis.astype(np.int32))
        plt.imshow(np.abs(data_cube_viz), cmap='cividis', origin='upper', aspect='auto', vmax=max_value)
        plt.colorbar(label='Magnitude')
        plt.title('Range-Velocity Plot')
        plt.xlabel('Range Bins (Distance in m)')
        plt.ylabel('Doppler Bins (Velocity in m/s)')
        plt.show()
        plt.savefig(f"range_velocity_plot_{target_idx}.png")
    
    
    if os.path.exists(matfile_name):
        if os.path.isfile(matfile_name):
            os.remove(matfile_name)
    return things


# factor is linear amplitude multiplier
def generate_gaussian_noise(factor, shape):
    return factor * (np.random.normal(size=shape) + 1j * np.random.normal(size=shape))


def sim_adc_operation(signal, noise_factor=1.5, signal_factor=0.15):
    noise = generate_gaussian_noise(noise_factor, signal.shape)
    return np.round(signal*signal_factor + noise)


def make_data_cube(signals, num_pulses):
    pri_length_samples = signals.shape[1] // num_pulses
    data_cube = np.zeros((num_pulses, signals.shape[0], pri_length_samples), dtype=np.complex128)
    for i in range(num_pulses):
        data_cube[i] = signals[:, i*pri_length_samples:(i+1)*pri_length_samples]
    
    return data_cube

# DFT based subbanding, batch version (do not use this for DFT based MVDR because it uses a huge amount of memory)
def separate_signal_into_frequency_bands(signal, num_bands, sampling_rate, min_freq=None, max_freq=None):
    signal = np.asarray(signal)
    if signal.ndim == 0 or signal.shape[-1] == 0:
        return [np.zeros_like(signal, dtype=complex) for _ in range(num_bands)]

    n_samples = signal.shape[-1]
    if min_freq is None:
        min_freq = -sampling_rate / 2.0
    if max_freq is None:
        max_freq = sampling_rate / 2.0

    fft = np.fft.fft(signal, axis=-1)
    fft_shifted = np.fft.fftshift(fft, axes=-1)
    freqs = np.fft.fftshift(np.fft.fftfreq(n_samples, 1.0 / sampling_rate))
    idx_range = np.where((freqs >= min_freq) & (freqs <= max_freq))[0]
    if len(idx_range) == 0:
        return [np.zeros_like(signal) for _ in range(num_bands)]

    banded = []
    base = len(idx_range) // num_bands
    extra = len(idx_range) % num_bands
    start = 0
    for i in range(num_bands):
        count = base + (1 if i < extra else 0)
        band_fft = np.zeros_like(fft_shifted)
        band_fft[..., idx_range[start:start+count]] = fft_shifted[..., idx_range[start:start+count]]
        band_ifft = np.fft.ifft(np.fft.ifftshift(band_fft, axes=-1), axis=-1)
        banded.append(band_ifft)
        start += count
    banded = np.array(banded)
    return banded


# iterator version that only generates 1 subband at a time. Good enough for MVDR, doesn't OOM even when many instances are in parallel.
def iterate_subbands_dft(signal, num_bands, sampling_rate, min_freq=None, max_freq=None):
    if num_bands == 1:
        yield signal
    else:    
        signal = np.asarray(signal)
        if signal.ndim == 0 or signal.shape[-1] == 0:
            return [np.zeros_like(signal, dtype=complex) for _ in range(num_bands)]

        n_samples = signal.shape[-1]
        if min_freq is None:
            min_freq = -sampling_rate / 2.0
        if max_freq is None:
            max_freq = sampling_rate / 2.0

        fft = np.fft.fft(signal, axis=-1)
        fft_shifted = np.fft.fftshift(fft, axes=-1)
        freqs = np.fft.fftshift(np.fft.fftfreq(n_samples, 1.0 / sampling_rate))
        idx_range = np.where((freqs >= min_freq) & (freqs <= max_freq))[0]
        if len(idx_range) == 0:
            return [np.zeros_like(signal) for _ in range(num_bands)]

        banded = []
        base = len(idx_range) // num_bands
        extra = len(idx_range) % num_bands
        start = 0
        for i in range(num_bands):
            count = base + (1 if i < extra else 0)
            band_fft = np.zeros_like(fft_shifted)
            band_fft[..., idx_range[start:start+count]] = fft_shifted[..., idx_range[start:start+count]]
            band_ifft = np.fft.ifft(np.fft.ifftshift(band_fft, axes=-1), axis=-1)
            yield band_ifft
            # banded.append(band_ifft)
            start += count
        # banded = np.array(banded)
    # return banded


# DFT subbanded MVDR. Expects input as signals-per-element. No need to reshape into PRIs.
# uses positions, bandwidth, and center freq to calculate the steering vector per subband
def beamform_mvdr_dft_2D(signals, num_bands, num_pulses, positions, azimuth, elevation, pri_length, sampling_rate, center_frequency, bandwidth):
    radar_cpi = np.zeros((num_pulses, signals.shape[0], int(signals.shape[1] / num_pulses)), dtype=np.complex128)
    
    for i in range(num_pulses):
        radar_cpi[i] = signals[:, i*pri_length:(i+1)*pri_length]

    uv = create_ned_unit_vector(azimuth, elevation)
    delays = np.dot(positions, uv)
    num_pulses = radar_cpi.shape[0]
    subband_freqs = np.linspace(-bandwidth/2, bandwidth/2, num_bands)

    def run_mvdr_on_pulse(pulse, num_bands, pri_length, sampling_rate, min_freq, max_freq, center_frequency, delays):
        bf_out = np.zeros(pri_length, dtype=np.complex128)
        for i, pulse_subband in enumerate(iterate_subbands_dft(pulse, num_bands, sampling_rate, min_freq, max_freq)):
            R = np.cov(pulse_subband)
            Rinv = np.linalg.pinv(R)
            subband_sv = np.exp(-2j * np.pi * delays * (center_frequency + subband_freqs[i])/ speed_of_light)
            mvdr_w = Rinv @ subband_sv / (subband_sv.conj().T @ Rinv @ subband_sv)
            bf_out += mvdr_w.conj().T @ pulse_subband
        # print("pulse MVDR done")
        return bf_out

    bf_results = Parallel(n_jobs=-1)(delayed(run_mvdr_on_pulse)(radar_cpi[p], num_bands, pri_length, sampling_rate, -bandwidth/2, bandwidth/2, center_frequency, delays) for p in range(num_pulses))
    bf_results = np.asarray(bf_results)
    # print("BF results shape ", bf_results.shape)
    return bf_results


def make_prototype_filter(num_taps=256, num_bands=128, sampling_rate=1.25e9):
    return firwin(num_taps, cutoff=sampling_rate/num_bands/2, window='hamming', fs=sampling_rate)


# signal: (num_samples) signal 
# filter: filter coeffs from make_prototype_filter()
# num_bands: number of subbands
# output: will return (num_bands, num_samples/num_bands) subbands from -sampling_rate/2 to sampling_rate/2
# fftshift has been applied to the ouput, so the subbands range from [-sampling_rate/2,...,0,...,sampling_rate/2]
def dft_polyphase_analysis_bank(signal, filter, num_bands, viz=False):
    M = num_bands
    H = filter

    # fix lengths
    length = (signal.shape[0] // M) * M
    signal2 = signal[:length]

    # decimate the signal into M-stride components
    sig_poly = signal2.reshape(-1, M).T

    if viz:
        plt.figure(figsize=(10, 4))
        plt.imshow(np.abs(sig_poly), cmap='viridis', aspect='auto', interpolation='none')
        plt.title("Decimated signal, unfiltered")
        plt.colorbar()
        plt.show()

    # decimate the filter into M-stride polyphase components
    H_poly = H.reshape(-1, M).T

    # apply the poly filters to the components
    sig_filtered = np.zeros(sig_poly.shape, dtype=np.complex128)
    for i in range(M):
        sig_filtered[i] = lfilter(H_poly[i, ::-1], [1.0], sig_poly[i])

    if viz:
        plt.figure(figsize=(10, 4))
        plt.imshow(np.abs(sig_filtered), cmap='viridis', aspect='auto', interpolation='none')
        plt.title("Decimated signal, filtered")
        plt.colorbar()
        plt.show()


    # apply M point DFT along axis=0
    sig_dft = np.fft.fftshift(np.fft.fft(sig_filtered, axis=0), axes=0)

    if viz:
        plt.figure(figsize=(10, 4))
        plt.imshow(np.abs(sig_dft), cmap='viridis', aspect='auto', interpolation='none')
        plt.title("DFT output")
        plt.colorbar()
        plt.show()

    return sig_dft


# subband_signals: (num_subbands, num_samples/num_subbands) subbanded signal bundle
# assumes the subbands are in fftshift order from [-sampling_rate/2,...,0,...,sampling_rate/2]
# if you use the above fn to subband, this works
# filter: filter coeffs from make_prototype_filter()
# num_bands: number of subbands
# output: will return reconstructed signal of (num_samples)
def dft_polyphase_synthesis_bank(subband_signals, filter, num_bands, viz=False):
    M = num_bands
    H = filter

    # decimate the filter into M-stride polyphase components
    H_poly = H.reshape(-1, M).T

    # reverse DFT
    sig_idft = np.fft.ifft(np.fft.ifftshift(subband_signals, axes=0), axis=0)

    if viz:
        plt.figure(figsize=(10, 4))
        plt.imshow(np.abs(sig_idft), cmap='viridis', aspect='auto', interpolation='none')
        plt.title("IDFT output")
        plt.colorbar()
        plt.show()

    # reverse filtering
    sig_unfiltered = np.zeros(sig_idft.shape, dtype=np.complex128)
    for i in range(M):
        sig_unfiltered[i] = lfilter(H_poly[i], [1.0], sig_idft[i])

    if viz:
        plt.figure(figsize=(10, 4))
        plt.imshow(np.abs(sig_unfiltered), cmap='viridis', aspect='auto', interpolation='none')
        plt.title("'Unfiltered' output")
        plt.colorbar()
        plt.show()

    # reverse decimation
    sig_undecimated = sig_unfiltered.T.reshape(-1, 1).squeeze()

    return sig_undecimated


# DFT subbanded delay-sum. Expects input as signals-per-element. No need to reshape into PRIs.
# uses positions, bandwidth, and center freq to calculate the steering vector per subband
def beamform_delay_sum_dft_2D(signals, num_bands, num_pulses, positions, azimuth, elevation, pri_length, sampling_rate, center_frequency, bandwidth):
    radar_cpi = np.zeros((num_pulses, signals.shape[0], int(signals.shape[1] / num_pulses)), dtype=np.complex128)
    
    for i in range(num_pulses):
        radar_cpi[i] = signals[:, i*pri_length:(i+1)*pri_length]

    # uv = create_ned_unit_vector(azimuth, elevation)
    # delays = np.dot(positions, uv)
    num_pulses = radar_cpi.shape[0]
    subband_len = bandwidth / num_bands
    subband_freqs = np.linspace(-bandwidth/2 + subband_len/2, bandwidth/2 - subband_len/2, num_bands)

    def run_ds_on_pulse(pulse, num_bands, pri_length, sampling_rate, min_freq, max_freq, center_frequency, azimuth, elevation, positions):
        bf_out = np.zeros(pri_length, dtype=np.complex128)
        for i, pulse_subband in enumerate(iterate_subbands_dft(pulse, num_bands, sampling_rate, min_freq, max_freq)):
            w = create_steering_vector_radar_coords(azimuth, elevation, positions, subband_freqs[i], center_frequency)
            bf_out += w.conj().T @ pulse_subband
            if i % 8 == 0:
                print(i)
        # print("pulse MVDR done")
        return bf_out

    bf_results = Parallel(n_jobs=8)(delayed(run_ds_on_pulse)(radar_cpi[p], num_bands, pri_length, sampling_rate, -bandwidth/2, bandwidth/2, center_frequency, azimuth, elevation, positions) for p in range(num_pulses))
    bf_results = np.asarray(bf_results)
    # print("BF results shape ", bf_results.shape)
    return bf_results


# Polyphase subbanded delay-sum. Expects input as signals-per-element. No need to reshape into PRIs.
# uses positions, bandwidth, and center freq to calculate the steering vector per subband
def beamform_delay_sum_polyphase_2D(signals, num_bands, num_pulses, positions, azimuth, elevation, pri_length, sampling_rate, center_frequency):
    radar_cpi = np.zeros((num_pulses, signals.shape[0], int(signals.shape[1] / num_pulses)), dtype=np.complex128)
    
    for i in range(num_pulses):
        radar_cpi[i] = signals[:, i*pri_length:(i+1)*pri_length]

    # uv = create_ned_unit_vector(azimuth, elevation)
    # delays = np.dot(positions, uv)
    num_pulses = radar_cpi.shape[0]
    subband_len = sampling_rate / num_bands
    subband_freqs = np.linspace(-sampling_rate/2 + subband_len/2, sampling_rate/2 - subband_len/2, num_bands)

    def run_ds_on_pulse(pulse, num_bands, pri_length, center_frequency, azimuth, elevation, positions):
        bf_temp = np.zeros((num_bands, pri_length // num_bands), dtype=np.complex128)
        fil = make_prototype_filter()
        subbands = np.zeros((num_bands, pulse.shape[0], pri_length // num_bands), dtype=np.complex128)
        for e in range(pulse.shape[0]):
            subbands[:, e, :] = dft_polyphase_analysis_bank(pulse[e], fil, 128)

        for i in range(num_bands):
            subband = subbands[i]
            w = create_steering_vector_radar_coords(azimuth, elevation, positions, subband_freqs[i], center_frequency)
            bf_temp[i] += w.conj().T @ subband
        
        bf_out = dft_polyphase_synthesis_bank(bf_temp, fil, num_bands)
        return bf_out

    bf_results = Parallel(n_jobs=-1)(delayed(run_ds_on_pulse)(radar_cpi[p], num_bands, pri_length, center_frequency, azimuth, elevation, positions) for p in range(num_pulses))
    bf_results = np.asarray(bf_results)
    # print("BF results shape ", bf_results.shape)
    return bf_results



# Polyphase subbanded MVDR. Expects input as signals-per-element. No need to reshape into PRIs.
# uses positions, bandwidth, and center freq to calculate the steering vector per subband
def beamform_mvdr_polyphase_2D(signals, num_bands, num_pulses, positions, azimuth, elevation, pri_length, sampling_rate, center_frequency):
    radar_cpi = np.zeros((num_pulses, signals.shape[0], pri_length), dtype=np.complex128)
    print(num_pulses)
    print(radar_cpi.shape)
    for i in range(num_pulses):
        radar_cpi[i] = signals[:, i*pri_length:(i+1)*pri_length]

    # uv = create_ned_unit_vector(azimuth, elevation)
    # delays = np.dot(positions, uv)
    num_pulses = radar_cpi.shape[0]
    subband_len = sampling_rate / num_bands
    subband_freqs = np.linspace(-sampling_rate/2 + subband_len/2, sampling_rate/2 - subband_len/2, num_bands)

    def run_mvdr_on_pulse(pulse, num_bands, pri_length, center_frequency, azimuth, elevation, positions):
        bf_temp = np.zeros((num_bands, pri_length // num_bands), dtype=np.complex128)
        fil = make_prototype_filter()
        subbands = np.zeros((num_bands, pulse.shape[0], pri_length // num_bands), dtype=np.complex128)
        for e in range(pulse.shape[0]):
            subbands[:, e, :] = dft_polyphase_analysis_bank(pulse[e], fil, num_bands)

        I = np.identity(128, dtype=np.complex128)

        for i in range(num_bands):
            subband = subbands[i]
            R = np.cov(subband)
            R += np.mean(np.linalg.svdvals(R)[-64:]) * I
            Rinv = np.linalg.pinv(R)
            subband_sv = create_steering_vector_radar_coords(azimuth, elevation, positions, subband_freqs[i], center_frequency)
            mvdr_w = Rinv @ subband_sv / (subband_sv.conj().T @ Rinv @ subband_sv)
            bf_temp[i] += mvdr_w.conj().T @ subband
        
        bf_out = dft_polyphase_synthesis_bank(bf_temp, fil, num_bands)
        return bf_out

    bf_results = Parallel(n_jobs=-1)(delayed(run_mvdr_on_pulse)(radar_cpi[p], num_bands, pri_length, center_frequency, azimuth, elevation, positions) for p in range(num_pulses))
    bf_results = np.asarray(bf_results)
    # print("BF results shape ", bf_results.shape)
    return bf_results



import torch


def beamform_ml_polyphase_2D(signals, num_bands, num_pulses, positions, azimuth, elevation, pri_length, sampling_rate, center_frequency, model, timesteps=256):
    print(signals.shape)
    radar_cpi = np.zeros((num_pulses, signals.shape[0], pri_length), dtype=np.complex128)
    print(num_pulses)
    print(radar_cpi.shape)
    num_elements_down = 4
    num_elements_east = 32

    device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
    # print("Using device: ", device)
  
    for i in range(num_pulses):
        radar_cpi[i] = signals[:, i*pri_length:(i+1)*pri_length]

    # uv = create_ned_unit_vector(azimuth, elevation)
    # delays = np.dot(positions, uv)
    num_pulses = radar_cpi.shape[0]
    subband_len = sampling_rate / num_bands
    subband_freqs = np.linspace(-sampling_rate/2 + subband_len/2, sampling_rate/2 - subband_len/2, num_bands)

    def run_ml_on_pulse(pulse, num_bands, pri_length, center_frequency, azimuth, elevation, positions, model):
        bf_temp = np.zeros((num_bands, pri_length // num_bands), dtype=np.complex128)
        fil = make_prototype_filter(num_taps=num_bands*2, num_bands=num_bands)
        num_elements = pulse.shape[0]

        subbands = np.zeros((num_bands, num_elements, pri_length // num_bands), dtype=np.complex128)
        for e in range(pulse.shape[0]):
            subbands[:, e, :] = dft_polyphase_analysis_bank(pulse[e], fil, num_bands)

        model.eval()

        batch_sz = 1
        azimuth = np.float32(azimuth)
        elevation = np.float32(elevation)
        theta = (
            torch.tensor([azimuth] * batch_sz)
            .view(batch_sz, 1, 1, 1)
            .expand(-1, 1, num_elements_down, num_elements_east)
        )
        phi = (
            torch.tensor([elevation] * batch_sz)
            .view(batch_sz, 1, 1, 1)
            .expand(-1, 1, num_elements_down, num_elements_east)
        )

        # Check the data types of the model's parameters
        # TODO: there shouldn't be buffers in the current model, but we should probably check to make sure
        dtypes = set(param.dtype for param in model.parameters())
        assert len(dtypes) == 1, "Model should not have mix-typed parameters"
        dtype = list(dtypes)[0]

        with torch.no_grad():
            for i in range(num_bands):
                # print("Subband ", i)
                subband_orig = subbands[i] # currently (128, pri_length // num_bands)
                subband = subband_orig[:, 0:256]
                subband = subband.reshape(num_elements_down, num_elements_east, -1) # (4, 32, pri_length // num_bands)
                subband = np.transpose(subband, axes=(2, 0, 1)) # (pri_length // num_bands, 4, 32)

                y_real = torch.tensor(subband.real.astype(np.float32)).unsqueeze(0)
                y_imag = torch.tensor(subband.imag.astype(np.float32)).unsqueeze(0)

                y_input = (
                    torch.cat([y_real, y_imag], dim=1).permute(0, 1, 2, 3).contiguous()
                )

                y_input = y_input.to(device, dtype=dtype)
                # append angle information to create ML model input
                # y_with_angles = torch.cat([y_input, theta, phi], dim=1)

                #angles batch is passed separately, so it can be used for multiple pulses
                angles_batch = torch.tensor([azimuth, elevation]).reshape(1, 1, 2).to(y_input.device, dtype=dtype)

                # inference
                output = model(y_input, angles_batch).detach().cpu()
                # the inference output represents modifications to the steering vector. Add them to steering vector to get the final weights
                svs_batch_transpose = torch.tensor(
                    create_steering_vector_radar_coords(
                        azimuth,
                        elevation,
                        positions,
                        subband_freqs[i],
                        center_frequency,
                    ).reshape(num_elements_down, num_elements_east),
                    dtype=torch.complex64,
                )
                svs_batch_transpose = svs_batch_transpose.unsqueeze(0).repeat(
                    1, 1, 1
                )
                real_out = output[:,:, 0] + svs_batch_transpose[:].real / num_elements
                imag_out = output[:,:, 1] - svs_batch_transpose[:].imag / num_elements


                # sub_data = np.transpose(sub_batch[p], axes=(2, 1, 0)).reshape(
                #     num_elements, -1
                # )
                
                ml_w = (
                    real_out[0].cpu().numpy() + 1j * imag_out[0].cpu().numpy()
                ).reshape(num_elements, 1)

                bf_temp[i] += (ml_w.T @ subband_orig).squeeze()


                # subband_sv = create_steering_vector_radar_coords(azimuth, elevation, positions, subband_freqs[i], center_frequency)
                # mvdr_w = Rinv @ subband_sv / (subband_sv.conj().T @ Rinv @ subband_sv)
                # bf_temp[i] += mvdr_w.conj().T @ subband
            
        bf_out = dft_polyphase_synthesis_bank(bf_temp, fil, num_bands)
        return bf_out

    # no point parallelizing, the CPU is pretty much choked
    bf_results = Parallel(n_jobs=2)(delayed(run_ml_on_pulse)(radar_cpi[p], num_bands, pri_length, center_frequency, azimuth, elevation, positions, model) for p in range(num_pulses))
    bf_results = np.asarray(bf_results)
    # print("BF results shape ", bf_results.shape)
    return bf_results

